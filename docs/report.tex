\documentclass[10pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Matthew Burket and Joel May}
\title{Programming Assignment 2 Report}

\begin{document}
\maketitle

\section{Data Structures}
\subsection{Q}
We used an \texttt{ArrayDeque<String>} for $Q$. We needed a simple queue that lets us enqueue and dequeue items. In Java, the \texttt{ArrayDeque} is one of the most basic queues. It was a trivial choice to make the queue hold \texttt{String}s for the nodes. There was no obvious contender on that choice.
\subsection{Visited}
We used a \texttt{HashSet<String>} for $visited$. The operations we need are inserting new URLs and checking for the existence of URLs. The \texttt{HashSet} gives us $O(1)$ time complexity for both of those operations (assuming hash functions of $O(1)$. The \texttt{HashSet} implements what we need and does the operations quickly.
\section{Top 10 most influential nodes}
\subsection{computed by mostInfluentialDegree}
\subsection{computed bymostInfluentialModular}
\subsection{computed by mostInfluentialSubModular}
\section{Pseudo Code}
\subsection{Constructor}
\begin{verbatim}
function NetworkInfluence(file)
    vertexCount = file.readInt()
    while file.hasMoreLines()
        line = file.readLine().split(" ")
        // edges is a HashMap<node, List<node>>.
        // Either initialize the list or append to the list if it exists.
        edges.createOrAppendToList(line[0], line[1])
        
        // nodes is a hashmap, so no duplicates are created when nodes are re-encountered
        nodes.add(line[0])
        nodes.add(line[1])
\end{verbatim}
\subsection{\texttt{outDegree}}
\begin{verbatim}
function outDegree(String v)
    if (edges.containKey(v))
        return edges.get(v).size();
	return 0
\end{verbatim}
\subsection{\texttt{shortestPath}}
\begin{verbatim}
function shortestPath
   	Queue toVisit
   	HashMap<String, String> parent
   	toVisit.add(u)
   	parent.put(u, null)
   	do
   	    currentNode = toVisit.remove()
   	    if currentNode == v
   	        backNode = currentNode
   	        Stack path
   	        do 
   	            path.push(backNode)
   	            backNode = parent.get(backend)
   	        while !backNode == u
   			
\end{verbatim}
\subsection{\texttt{distance(String u, String v)}}
\begin{verbatim}
function distance(String u, String v) 
   	return shortestPath(u,v).size() - 1
\end{verbatim}
\subsection{\texttt{distance(ArrayList<String> s, String v)}}
\begin{verbatim}
function distance(ArrayList<String> s, String v) 
        minDistance = Int.MAX_VALUE
    for node in s
        int thisDist = shortestPath(u,v)
        if thisDist != -1 && thisDist < minDistance
            minDistance = thisDist
        if thisIdst == Int.MAX_VALUE
            return -1
        return minDist
\end{verbatim}
\subsection{\texttt{influence(ArrayList<String> s)}}
\subsection{\texttt{mostInfluentialDegree(int k)}}
\subsection{\texttt{mostInfluentialModular(int k)}}
\subsection{\texttt{mostInfluentialSubModular(int k)}}
\section{Run-time}
\subsection{Constructor}
\subsection{\texttt{outDegree}}
We assume that perfect hash function exists, thus $O(1)$ is need for the \texttt{containKey(v)} method and the run-time for \texttt{get(v)} is also $O(1)$. The call for getting the size of the \texttt{ArrayList} of the key is also $O(1)$.
Thus the run time is $O(1)$.
\end{document}