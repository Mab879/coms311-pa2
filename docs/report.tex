\documentclass[10pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Matthew Burket and Joel May}
\title{Programming Assignment 2 Report}
\begin{document}
\maketitle
\section{Data Structures}
\subsection{Q}
\subsection{Visited}
\section{Top 10 most influential nodes}
\subsection{computed by mostInfluentialDegree}
\subsection{computed bymostInfluentialModular}
\subsection{computed by mostInfluentialSubModular}
\section{Pseudo Code}
\subsection{Constructor}
\subsection{\texttt{outDegree}}
\begin{verbatim}
function outDegree(String v)
    if (edges.containKey(v))
       return edges.get(v).size();
	return 0
\end{verbatim}
\subsection{\texttt{shortestPath}}
\begin{verbatim}
function shortestPath
   	Queue toVisit
   	HashMap<String, String> parent
   	toVisit.add(u)
   	parent.put(u, null)
   	do
   		currentNode = toVisit.remove()
   		if currentNode == v
   			backNode = currentNode
   			Stack path
   			do 
   				path.push(backNode)
   				backNode = parent.get(backend)
   			while not backNode == u
   			
\end{verbatim}
\subsection{\texttt{distance(String u, String v)}}
\begin{verbatim}
function distance(String u, String v) 
   	return shortestPath(u,v).size() - 1
\end{verbatim}
\subsection{\texttt{influence(String u) }}
\begin{verbatim}
function influence(String u)
	TreeMap<Integer, Integer> tieredCounts = tieredBfs(u);
	sum = 0
	
	for depthAndCount in tieredCounts
		sum += 1 / 2^depthAndCount.key * depthAndCount.value
		
	return sum
\end{verbatim}	
\subsection{\texttt{distance(ArrayList<String> s, String v)}}
\begin{verbatim}
function distance(ArrayList<String> s, String v) 
    int minDistance = Int.MAX_VALUE
    for node in s
        int thisDist = shortestPath(u,v)
        if thisDist != -1 && thisDist < minDistance
            minDistance = thisDist
        if thisIdst == Int.MAX_VALUE
            return -1
        return minDist
\end{verbatim}
\subsection{\texttt{influence(ArrayList<String> s)}}
\begin{verbatim}
function influence
\end{verbatim}
\subsection{\texttt{mostInfluentialDegree(int k)}}
\subsection{\texttt{mostInfluentialModular(int k)}}
\subsection{\texttt{mostInfluentialSubModular(int k)}}
\subsection{\texttt{tieredBfs(Iterable<String> startingNodes)}}
This method is private, however it is used two places in public methods. Thus,
it is placed here for brevity in the public methods. 
\begin{verbatim}
function tieredBfs
    TreeMap<Int, Int> ret = new TreeMap<>();
    ArrayDeque<Map.Entry<String, Integer>> toVisit = new ArrayDeque<>()
    HashSet<String> visited = new HashSet<>()
	
    for startingNode in startingNodes
        toVisit.add(new Map.Entry<>(startingNode, 0))
        visited.add(startingNode)
	
    do
        Map.Entry<String, Integer> currentNode = toVisit.remove()
        int newCount = ret.getOrDefault(currentNode.getValue(), 0) + 1        
        ret.put(currentNode.value, newCount
        
        if edges.containsKey(currentNode.getKey())
            for dst in edges.get(currentNode.getKey())
                if not visited.contains(dst)
                    toVisit.add(new Map.Entry(dst, currentNode.value + 1)
                    visited.add(dst)
     while not toVisit.isEmpty()
     
     return ret
\end{verbatim}
\section{Run-time}
\subsection{Constructor}
\subsection{\texttt{outDegree}}
We assume that perfect hash function exists thus $O(1)$ is need for the\texttt{containKey(v)} method and the run-time for \texttt{get(v)} is also $O(1)$. The call for getting the size of the \texttt{ArrayList} of the key is also $O(1)$.
Thus the run time is $O(1)$.
\end{document}